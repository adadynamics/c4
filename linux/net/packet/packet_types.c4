// for compatibility with glibc getifaddrs

union IfaIfu:
    SockAddr* ifu_broadaddr        // Broadcast address (IFF_BROADCAST)
    SockAddr* ifu_dstaddr          // Point-to-point destination address
:

struct Ifaddrs:
    Ifaddrs* ifa_next              // Pointer to the next structure
    char* ifa_name                 // Name of this network interface
    u32 ifa_flags                  // Flags as from SIOCGIFFLAGS ioctl
    SockAddr* ifa_addr             // Network address of this interface
    SockAddr* ifa_netmask          // Netmask of this interface
    IfaIfu ifa_ifu                 // Union: broadcast or destination address
    void* ifa_data                 // Address-specific data
:

@define ifa_broadaddr ifa_ifu.ifu_broadaddr
@define ifa_dstaddr   ifa_ifu.ifu_dstaddr

// Functions

extern "C":
    fn getifaddrs(Ifaddrs** ifap) -> i32
    fn freeifaddrs(Ifaddrs* ifa)
:



// --- ifmap struct ---
struct IfMap:
    ulong mem_start
    ulong mem_end
    ushort base_addr
    u8 irq
    u8 dma
    u8 port
    u8 [3]spare
:

// --- flattened union for if_settings ---
struct IfSettingsUnion:
    RawHdlcProto* raw_hdlc
    CiscoProto* cisco
    FrProto* fr
    FrProtoPvc* fr_pvc
    FrProtoPvcInfo* fr_pvc_info
    X25HdlcProto* x25
    SyncSerialSettings* sync
    Te1Settings* te1
:

// --- main if_settings struct ---
struct IfSettings:
    u32 type       // Type of physical device or protocol
    u32 size       // Size of data allocated by caller
    IfSettingsUnion ifs_ifsu
:

// --- field defines (for compatibility) ---
@define ifs_raw_hdlc = ifs_ifsu.raw_hdlc
@define ifs_cisco = ifs_ifsu.cisco
@define ifs_fr = ifs_ifsu.fr
@define ifs_fr_pvc = ifs_ifsu.fr_pvc
@define ifs_fr_pvc_info = ifs_ifsu.fr_pvc_info
@define ifs_x25 = ifs_ifsu.x25
@define ifs_sync = ifs_ifsu.sync
@define ifs_te1 = ifs_ifsu.te1



enum NetDeviceFlags:
    IFF_UP             = 1 << 0   // Interface is up
    IFF_BROADCAST      = 1 << 1   // Broadcast address valid
    IFF_DEBUG          = 1 << 2   // Internal debugging flag
    IFF_LOOPBACK       = 1 << 3   // Loopback interface
    IFF_POINTOPOINT    = 1 << 4   // Point-to-point link
    IFF_NOTRAILERS     = 1 << 5   // Avoid use of trailers
    IFF_RUNNING        = 1 << 6   // Resources allocated
    IFF_NOARP          = 1 << 7   // No ARP protocol
    IFF_PROMISC        = 1 << 8   // Receive all packets
    IFF_ALLMULTI       = 1 << 9   // Receive all multicast packets
    IFF_MASTER         = 1 << 10  // Master of a load balancer
    IFF_SLAVE          = 1 << 11  // Slave of a load balancer
    IFF_MULTICAST      = 1 << 12  // Supports multicast
    IFF_PORTSEL        = 1 << 13  // Can select media type
    IFF_AUTOMEDIA      = 1 << 14  // Auto media select active
    IFF_DYNAMIC        = 1 << 15  // Dialup device with changing addresses
    IFF_LOWER_UP       = 1 << 16  // Physical link up
    IFF_DORMANT        = 1 << 17  // Waiting for external event
    IFF_ECHO           = 1 << 18  // Echo sent packets
:



@define IFHWADDRLEN = 6


union IfReqName:
    char [IFNAMSIZ]ifrn_name
:

union IfReqUnion:
    SockAddr ifru_addr
    SockAddr ifru_dstaddr
    SockAddr ifru_broadaddr
    SockAddr ifru_netmask
    SockAddr ifru_hwaddr
    i16 ifru_flags
    i32 ifru_ivalue
    i32 ifru_mtu
    IfMap ifru_map
    char [IFNAMSIZ]ifru_slave
    char [IFNAMSIZ]ifru_newname
    void *ifru_data
    IfSettings ifru_settings
:



struct Ifreq:
    IfReqName ifr_ifrn
    IfReqUnion ifr_ifru
:

// --- alias defines (1:1 with C macros) ---

@define ifr_name = ifr_ifrn.ifrn_name
@define ifr_hwaddr = ifr_ifru.ifru_hwaddr
@define ifr_addr = ifr_ifru.ifru_addr
@define ifr_dstaddr = ifr_ifru.ifru_dstaddr
@define ifr_broadaddr = ifr_ifru.ifru_broadaddr
@define ifr_netmask = ifr_ifru.ifru_netmask
@define ifr_flags = ifr_ifru.ifru_flags
@define ifr_metric = ifr_ifru.ifru_ivalue
@define ifr_mtu = ifr_ifru.ifru_mtu
@define ifr_map = ifr_ifru.ifru_map
@define ifr_slave = ifr_ifru.ifru_slave
@define ifr_data = ifr_ifru.ifru_data
@define ifr_ifindex = ifr_ifru.ifru_ivalue
@define ifr_bandwidth = ifr_ifru.ifru_ivalue
@define ifr_qlen = ifr_ifru.ifru_ivalue
@define ifr_newname = ifr_ifru.ifru_newname
@define ifr_settings = ifr_ifru.ifru_settings



enum PacketType:
    PACKET_HOST = 0        // To us
    PACKET_BROADCAST = 1   // To all
    PACKET_MULTICAST = 2   // To group
    PACKET_OTHERHOST = 3   // To someone else
    PACKET_OUTGOING = 4    // Outgoing of any type
    PACKET_LOOPBACK = 5    // MC/BRD frame looped back
    PACKET_USER = 6        // To user space
    PACKET_KERNEL = 7      // To kernel space
    PACKET_FASTROUTE = 6   // Fastrouted frame (unused)
:



struct SockaddrLL:
    u16 sll_family
    u16 sll_protocol
    i32 sll_ifindex
    u16 sll_hatype
    u8 sll_pkttype
    u8 sll_halen
    u8 [8]sll_addr
:

impl SockaddrLL:

:


enum PacketSocketOption:
    PACKET_ADD_MEMBERSHIP = 1
    PACKET_DROP_MEMBERSHIP = 2
    PACKET_RECV_OUTPUT = 3
    // Value 4 reserved for obsolete turbo-packet
    PACKET_RX_RING = 5
    PACKET_STATISTICS = 6
    PACKET_COPY_THRESH = 7
    PACKET_AUXDATA = 8
    PACKET_ORIGDEV = 9
    PACKET_VERSION = 10
    PACKET_HDRLEN = 11
    PACKET_RESERVE = 12
    PACKET_TX_RING = 13
    PACKET_LOSS = 14
    PACKET_VNET_HDR = 15
    PACKET_TX_TIMESTAMP = 16
    PACKET_TIMESTAMP = 17
    PACKET_FANOUT = 18
    PACKET_TX_HAS_OFF = 19
    PACKET_QDISC_BYPASS = 20
    PACKET_ROLLOVER_STATS = 21
    PACKET_FANOUT_DATA = 22
    PACKET_IGNORE_OUTGOING = 23
    PACKET_VNET_HDR_SZ = 24
:



enum PacketFanoutMode:
    PACKET_FANOUT_HASH = 0
    PACKET_FANOUT_LB = 1
    PACKET_FANOUT_CPU = 2
    PACKET_FANOUT_ROLLOVER = 3
    PACKET_FANOUT_RND = 4
    PACKET_FANOUT_QM = 5
    PACKET_FANOUT_CBPF = 6
    PACKET_FANOUT_EBPF = 7
:

enum PacketFanoutFlag:
    PACKET_FANOUT_FLAG_ROLLOVER = 0x1000
    PACKET_FANOUT_FLAG_UNIQUEID = 0x2000
    PACKET_FANOUT_FLAG_IGNORE_OUTGOING = 0x4000
    PACKET_FANOUT_FLAG_DEFRAG = 0x8000
:

enum PacketMembershipType:
    PACKET_MR_MULTICAST = 0     // Join a multicast group
    PACKET_MR_PROMISC = 1       // Enable promiscuous mode
    PACKET_MR_ALLMULTI = 2      // Receive all multicast packets
    PACKET_MR_UNICAST = 3       // Receive unicast packets (if supported)
:


struct PacketMreq:
    i32 mr_ifindex
    u16 mr_type
    u16 mr_alen
    u8 [8]mr_address
:



